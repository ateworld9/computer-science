# А. Яндекс.Метрика

Перед вами Василий - очень деловой человек, который просто не может представить свою жизнь без подсчета практически всего, что угодно: машин, проезжающих за окном офиса, денег, которые потратил на такси с утра, количество плиток на потолке... Но Василию потребовалось направить свою энергию в нужное русло - посчитать на сервисе по просмотру картинок котиков, к развитию которого он приложил немало усилий, количество использований функции добавления лайков уникальными пользователями, ведь такой подсчет не просто поможет скоротать время с интересом, а и способен принести ощутимую пользу: понять, насколько часто пользователям нравятся картинки с котиками! Также Василий подумал, что неплохо было бы и добавление комментариев считать, и сохранение картинок в избранное... Но Василий очень занят пересчитыванием кофейных зерен во время обеденного перерыва (а как без этого), потому ему очень нужна ваша помощь в решении задачи!

Требуется написать функцию-обертку, обеспечивающую подсчет уникальных пользователей в день, вызвавших функцию func, принимающую произвольное количество аргументов args . На вход обертке приходит функция, которую необходимо вызвать.

Возвращаемым значением будет также функция, принимающая следующие аргументы:

credentials - объект с полями login: string | null | undefined; password: string | null | undefined, date: Date, дата последнего логина.
args - аргументы для вызова функции func.
Результатом выполнения данной функции будет массив объектов { date: 'YYYY-MM-DD', users: number }, которые содержат в себе информацию о количестве уникальных пользователей за день, например [{ date: ’2011-01-26’, users: 3}].

Уникальными считаются пользователи, у которых различаются логин или пароль. Если логин или пароль не являются строкой или пусты, то требуется вернуть текущее сохраненное количество уникальных пользователей, притом функция func в случае неполных данных вызываться не должна.

Сигнатура функции-обертки:

```
/**
 * @typedef {Object} Answer
 * @property {Date} date - дата, для которой подсчитано количество уникальных пользователей
 * @property {number} users - количество уникальных пользователей
 *
 *
 * @typedef {Object} Credentials
 * @property {string | null | undefined} login - логин пользователя
 * @property {string | null | undefined} password - пароль пользователя
 * @property {Date} date - дата последнего логина
 *
 * @param {Function} func  - произвольная функция, вызываемая для пользователей с присутствующим логином и паролем
 * @return {(credentials: Credentials, ...args) => Answer[]} - результат подсчета количества уникальных пользователей для каждого дня
 */
module.export = (func) => {
    ...
}
```

Формат ввода

Пример 1:

```
// Тестовые данные
const wrappedFunc = metrikaWrapper(() => (console.log('called')));

console.log(wrappedFunc({ login: 'a', password: 'a', date: new Date('2023-06-28')}));

console.log(wrappedFunc({ login: NaN, password: 'a', date: new Date('2023-06-28')}));

console.log(wrappedFunc({ login: 'c', date: new Date('2023-06-28')}));
```

Пример 2:

```
// Тестовые данные
const wrappedFunc = metrikaWrapper(() => (console.log('called')));

console.log(wrappedFunc({ login: 'a', password: 'a', date: new Date('2023-06-28')}));

console.log(wrappedFunc({ login: 'b', password: 'a', date: new Date('2023-06-28')}));

console.log(wrappedFunc({ login: 'c', password: 'c', date: new Date('2023-06-28')}));
```

Формат вывода
Пример 1:

```
// Результат
called
[ { date: '2023-06-28', users: 1 } ]
[ { date: '2023-06-28', users: 1 } ]
[ { date: '2023-06-28', users: 1 } ]
```

Пример 2:

```
// Результат
called
called
[ { date: '2023-06-28', users: 1 } ]
called
[ { date: '2023-06-28', users: 2 } ]
called
[ { date: '2023-06-28', users: 3 } ]
```
