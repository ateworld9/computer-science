# Linux

### [Основное](./main.md)

### [Вспомогательные команды](./auxilary_commands.md)

### [Перенаправление](./redirection)

### [Переменные окружения](./environment)

### [Управление пользователями](./user_management)

### Привилегии(доступ к файлу)

`id` — выводит информацию об идентичности пользователя;

- `chmod *600 foo.txt*` — изменяет режим доступа к файлу;

  | Восьмеричное | Двоичное | Режим доступа |
  | ------------ | -------- | ------------- |
  | 0            | 000      | ---           |
  | 1            | 001      | --x           |
  | 2            | 010      | -w-           |
  | 3            | 011      | -wx           |
  | 4            | 100      | r--           |
  | 5            | 101      | r-x           |
  | 6            | 110      | rw-           |
  | 7            | 111      | rwx           |

  второй вариант u+x,go=rx
  u — user
  g — group
  o — other(world)
  a — all

  - — добавить права

  * — отнять права
    = — установить конкретные права(независимо какие были)

- `umask` — определяет разрешения доступа к файлам по умолчанию
  umask 0022 — стандартное значение ubuntu, каждое число это восьмеричное представление разрешения(см. `chmod`)
  - первое число
    Первый атрибут — бит setuid (восьмеричное значение 4000). Если это разрешение применяется к выполняемому файлу, в качестве эффективного идентификатора пользователя для процесса устанавливается не идентификатор реального
    пользователя (пользователя, фактически запустившего программу), а идентификатор владельца программы. Чаще этот бит устанавливается для программ,
    владельцем которых является суперпользователь. Когда обычный пользователь
    запускает программу с установленным битом setuid, принадлежащую пользователю root, программа выполняется с эффективными привилегиями суперпользователя. Это дает возможность программам обращаться к файлам и каталогам,
    недоступным для обычного пользователя. Очевидно, что из-за возникающих
    проблем безопасности число таких программ в системе должно быть сведено
    к минимуму.
    Второй редко используемый атрибут — бит setgid (восьмеричное значение 2000).
    По аналогии с битом setuid он устанавливает эффективный идентификатор группы для процесса, выбирая вместо идентификатора группы реального пользователя
    группу владельца файла. Если установить бит setgid для каталога, вновь создаваемые файлы в этом каталоге будут принадлежать группе владельца каталога, а не
    группе владельца файла, создавшего его. Это разрешение может пригодиться для
    установки на каталоги, содержимое которых должно быть доступно всем членам
    основной группы владельца каталога, независимо от принадлежности к основной
    группе владельца файла.
    Третий атрибут называется битом sticky (восьмеричное значение 1000). Это пережиток, оставшийся от первых версий Unix, которые предоставляли возможность
    пометить выполняемый файл как «невытесняемый». Linux игнорирует бит sticky
    у файлов, но если установить его для каталога, он не позволит пользователю удалять или переименовывать файлы, если только пользователь не является владельцем каталога, владельцем файла или суперпользователем. Это разрешение часто
    применяется для управления доступом к общим каталогам, таким как /tmp.
    второе число — маска для владельца
    третье число — маска для группы
    четвертое число — маска для остальных
    Пример: маска 0022
    | Исходный режим доступа к файлу | --- | rw- | rw- | rw- |
    | ------------------------------ | --- | --- | --- | --- |
    | Маска | 000 | 000 | 010 | 010 |
    | Результат | --- | rw- | r-- | r-- |

`su` — запускает командную оболочку от имени другого пользователя;
`sudo` — выполняет команду от имени другого пользователя;
`chown` — изменяет владельца файла;
`chgrp` — изменяет группу файла;
`passwd` — изменяет пароль пользователя.

`fuser` —

### Процессы

- Как действует процесс
  **Процесс** — это среда выполнения для работы экземпляра программы.
  **Программа может запускать программы**, по принципу: _родительский процесс_ запускает _дочерний процесс_.
  При запуске ядро инициирует несколько задач в виде процессов и запускает программу `init`/`systemd` (PID 1)
  Ядро хранит информацию обо всех процессах, чтобы упорядочить их работу. Каждому процессу ядро присваивает _Process ID_ (PID), следит за выделенной памятью и готовностью процессов возобновить выполнение.
  **PID 1** выполняет последовательность сценариев начальной загрузки из _`/etc`_, которые запускают системные службы(многие реализованы как daemon).
  daemon — программа, работающая в фоновом режиме.
- `ps` — выводит список процессов, выполняющихся в текущий момент
  **TTY**(teletype) — информация об управляющем терминале процесса. Символ **_?_** указывает на отсутствие управляющего терминала
  **TIME —** объем процессорного времени, потребленного процессом.
  - **STAT** — содержит информацию о текущем состоянии процесса.
    | Состояние | Значение |
    | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | R | Выполняется. Процесс выполняется или готов к выполнению. |
    | S | Приостановлен. Процесс временно не выполняется; скорее всего, находится в ожидании определенного события, такого как нажатие клавиши или прибытие сетевого пакета. |
    | D | Приостановлен без возможности прерывания. Процесс ожидает завершения операции ввода/вывода, например, дисковым устройством. |
    | T | Остановлен. Процесс принудительно остановлен. |
    | Z | Недействующий процесс-«зомби». Это дочерний процесс, который завершился, но не был удален родителем. |
    | < | Высокоприоритетный процесс. Существует возможность наиболее важным процессам выделить больше процессорного времени. Данное свойство процесса называется niceness (уступчивость). Про процессы с более высокими приоритетами говорят, что они менее уступчивы, потому что потребляют больше процессорного времени, оставляя меньше другим процессам |
    | N | Низкоприоритетный процесс. Процесс с низким приоритетом (или уступчивый процесс) получает процессорное время только после того, как будут обслужены процессы с более высоким приоритетом |
    Параметры:
    x —
- `strace -p` _pid_ — отображают каждый системный вызов, выполняемый процессом, и каждый получаемый им сигнал.
  unix & linux 4.8

`top` — выводит задачи
`jobs` — выводит список активных заданий
`bg` — переводит задание в фоновый режим работы
`fg` — переводит задание в режим работы на переднем плане

- `kill` -сигнал PID — посылает сигнал процессу
  Сигналы (kill -l — все сигналы):
  | Номер | Имя | Значение |
  | ------------------------------------------------------------ | --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | 2 | INT (Interrupt) | Прервать. Выполняет ту же функцию, что и нажатие комбинации CTRL+C в терминале. Обычно приводит к завершению программы |
  | 3 | QUIT | Выйти |
  | 9 | KILL | Уничтожить. Это специальный сигнал. В большинстве случаев программы могут сами решать, как реагировать на сигналы, вплоть до полного их игнорирования, но сигнал KILL в действительности никогда не передается целевой программе. Вместо этого ядро немедленно завершает указанный процесс. Когда процесс завершается таким способом, он не имеет возможности «прибрать за собой» или сохранить результаты своей работы. По этой причине сигнал KILL следует использовать только как крайнее средство, когда другие сигналы на завершение программы не приводят к желаемому результату |
  | 11 | SEGV | Ошибка сегментации. Этот сигнал посылается программе, предпринявшей попытку недопустимого обращения к памяти, то есть |
  | попытку выполнить запись в память, доступ к которой запрещен |
  | 15 | TERM | Завершить. Это сигнал по умолчанию, посылаемый командой kill. |
  Если программа достаточно «живая», чтобы принять этот сигнал, она
  завершится |
  | 18 | CONT | Продолжить. Этот сигнал восстанавливает нормальную работу процесса после сигнала STOP |
  | 19 | STOP | Приостановить. Этот сигнал заставляет процесс приостановиться, не завершаясь. Подобно сигналу KILL, он не передается целевому процессу и потому не может быть проигнорирован им |
  | 20 | TSTP | Сигнал «стоп» с клавиатуры. Этот сигнал посылается терминалом после нажатия комбинации CTRL+Z. В отличие от сигнала STOP, TSTP передается программе, и программа может решить игнорировать его |
  | 28 | WINCH | Изменение окна. Этот сигнал посылается системой при изменении
  размеров окна терминала. Некоторые программы, такие как top
  и less, реагируют на этот сигнал, обновляя свой вывод в соответствии с новыми размерами окна терминала |

`killall *[-u пользователь] [-сигнал] имя*` — останавливает процессы по именам
`shutdown` — останавливает или перезагружает систему

`systemctl` — все активные юниты(службы, сокеты, уст-ва…)
`systemctl enable` _postgres_ — запускать при загрузке
`systemctl disable`_postgres_ — не запускать при загрузке
`systemctl start` — запускает _юнит_
`systemctl stop` — останавливает

`systemctl restart`— перезапускает/запускает

`systemctl status` — показывает состояние
`systemctl kill`_шаблон_ — отправляет сигнал в модуль соответствующий _шаблону_

`systemctl isolate` _цель_ — Изменить режим работы на _целевой_
`systemctl get-default` — цель при загрузке
`systemctl set-default` — установить цель при загрузке
`systemctl list-unit --type=target` — посмотреть все цели

`systemctl reboot` — перезагрузка компьютера

`systemctl daemon-reload` — перезагружает _модули_ и конфигурацию **systemctl**

- `cron` — планировщик запуска команд
- запустить node как сервис управляемый **systemd**

  1. создать файл в `/etc/systemd/system/node-app.serivce`

     - node-app.service

       ```
       [Unit]
       Description=Social Network app backend(nodeJS) daemon

       [Service]
       Environment=NODE_ENV=production
       Environment=PORT=3001
       Type=simple
       User=ubuntu
       Group=ubuntu
       ExecStart=/usr/bin/node /path/to/app
       Restart=always
       # Отправка логов syslog
       # StandardOutput=syslog
       # StandardError=syslog
       # SyslogIdentifier=myapp
       [Install]
       WantedBy=multi-user.target
       ```

  2. `systemd enable node-app`
  3. `systemd daemon-reload`
  4. `systemd start node-app`

### Управление пакетами

**dpkg** — Низкоуровневый инструмент, решает такие задачи, как установка и удаление файлов пакетов;

**apt-get**, **apt**, **aptitude** — Высокоуровневые инструменты, выполняющие поиск метаданных и разрешение зависимостей.

`apt-cache search` *искомая*строка\_ — Поиск пакета в репозитории

`apt-cache install` *имя*пакета —\_ Установка пакета из репозитория

`dpkg -i` *файл*пакета\_ — Установка пакета из файла пакета

`apt-get remove` *имя*пакета\_ — Удаление пакета

`apt-get upgrade` — Обновление пакетов из репозитория

`dpkg -i` *файл*пакета\_ — Обновление пакета из файла пакета

`dpkg -l` — Список установленных пакетов

`dpkg -s` *имя*пакета\_ — Определение, установлен ли пакет

`apt-cache show` *имя*пакета\_ — Вывод информации об установленном пакете

`dpkg -S` *имя*файла\_ — Поиск пакета по установленному файлу

### Устройства хранения

`mount` — монтирует файловые системы;
`umount` — размонтирует файловые системы;
`fsck` — проверяет и восстанавливает файловые системы;
`fdisk` — инструмент для работы с таблицей разделов;
`mkfs` — создает файловые системы;
`dd` — выполняет запись данных блоками непосредственно в устройство;
`genisoimage` (`mkisofs`) — создает файл образа ISO 9660;
`wodim` (`cdrecord`) — записывает данные на оптический носитель;
`md5sum` — вычисляет контрольную сумму MD5.

### Сети TCP/IP

- Теория
  Интернет представляет собой совокупность частных сетей, принадлежащих провайдерам интренет, которые соединяются в “точках обмена трафиком”(peering points)
  - Сетевые стандарты и документация
    Request For Comments(RFC) — формат документов, в котором публикуются стандарты протоколов
    Документы RFC имеют порядковые номера
    Изменения и дополнения публикуются в виде новых документов с собственными номерами
    Дополнительные серии
    - FYI (For Your Information) — это вводные или информационные материалы, предназначенные для широкой аудитории. Как правило, именно с них лучше всего начинать изучать незнакомую тему.
    - BCP (Best Current Practice) — описывают рекомендуемые процедуры для администраторов вебсайтов в Интернете. Они содержат адми нистративные предписания и представляют большую ценность для системных администраторов.
    - STD (Standart) — содержат описания протоколов И нтернета, прошедших процедуру проверки и тестирования в I ETF и формально принятых в качестве стандартов.
      _TCP/IP_ — это семейство сетевых протоколов, ориентированных на совместную работу
      ![Untitled](Linux%20f9b903ea36464de99f152d6ee4d1b7e6/Untitled.png)
  - IP (lnternet Protocol) — обеспечивает передачу пакетов данных с одного компьютера на другой (RFC791);
  - ICMP (lnternet Control Message Protocol) — протокол управляющих сообщений
    в Интернете) отвечает за различные виды н изкоуровневой поддержки протокола
    IP, включая сообщения об ошибках, вспомогательные маршрутизирующие запросы и отладочные сообщения (RFC792);
  - ARP (Address Resolution Protocol) — обеспечивает трансляцию IР-адресов в аппаратные адреса (RFC826);
  - UDP (User Datagram Protocol) — обеспечивает непроверяемую одностороннюю доставку данных (RFC768);
  - ТСР (Transmission Control Protocol) протокол управления передачей) обеспечивает надежный дуплексный канал связи между процессами на двух компьютерах с возможностью управления потоками и контроля ошибок (RFC793)
  - IPv4
    тк адресного пространства IPv4 не хватает на все устройства, используются следующие технологии для оптимизации адресного пространства
    - Protocol NAT(Network Address Translation) — Позволяет целым сетям машин скрываться за 1 IPv4 адресом
    - Технология CIDR(Classless Inter-Domain Routing) — гибко разделяет сети и способствует эффективной магистральной маршрутизации
  ### Пакеты и их инкапсуляция
  ![Untitled](Linux%20f9b903ea36464de99f152d6ee4d1b7e6/Untitled%201.png)
  Каждый уровень состоит из:
  - Заголовка — откуда прибыл пакет, куда он направляется, контрольные суммы, информация характерная для протокола
  - Полезная нагрузка — данные
    Готовящийся к отправке пакет передается вниз по стеку протоколов и каждый добавляет в него собственный заголовок
    ![Untitled](Linux%20f9b903ea36464de99f152d6ee4d1b7e6/Untitled%202.png)
    Канальный уровень разделен на две части:
  - MAC(Media Access Control) — работает с аудиовизуальной информацией и передает пакеты по проводам
  - LLC(Link Layer Control) — формирует фреймы
    На канальном уровне к пакетам добавляются заголовки и между ними вставляются разделители
  - заголовки — содержат информацию об адресах канального уровня и контрольные суммы
  - разделители — помогают клиенту понять где закончивается один пакет и начинается другой
    **Максимальный размер передаваемого блока**
    Размер сетевых пакетов ограничивается хар-ми аппаратных средств и протоколами
    MTU(Maximum Transfer Unit) — Максимальная еденица передачи
    ![Untitled](Linux%20f9b903ea36464de99f152d6ee4d1b7e6/Untitled%203.png)

### DNS

DNS — Распределенная база данных

### Запросы и ответы

DNS-запрос состоит из имени и типа записи. Возвращаемый ответ — это набор “записей о ресурсах”, которые реагирует на запрос(или ответ указывающий на то что имя и тип записи не существует)

Серверы, не знающие ответ на запрос, возвращают записи ресурсов, которые могут помочь клиенту найти сервер, знающий ответ.

### Пространство имен DNS

Пространство имен DNS — дерево с двумя основными ветвями, соответсвующие прямым и обратным преобразованиям.

- Прямые преобразования Domain → IP
- Обратные преобразования IP → Domain
  Существует два типа доменов верхнего уровня:
- country code top-level domain(ccTLD) — ru en
- generic top level domain(gTLD) — com org

### Как работает система DNS

### База данных DNS

**Команды синтаксического анализатора**

`$ORIGIN` — стандартное имя домена

`$INCLUDE` —

`$TTL` —

**Записи о ресурсах**

Зонные

- **SOA** Start Of Authority — Определение DNS-зоны
- **NS** Name Server — Определение серверов имен зоны, делегирование полномочий поддоменам

Базовые

- **A** IPv4 — Преобразование Domain Name в IPv4 адрес
- **AAAA** IPv6 — Преобразование Domain Name в IPv6 адрес
- **PTR** Pointer \*\*\*\*— Преобразование IP-адреса в Domain Name
- **MX** Mail Exchanger \*\*\*\*— Управление маршрутизацией почты

Безопасность

- **DS** Delegation Signer — Хеширует подписанный ключ дочерней зоны
- **DNSKEY** Public Key — Открытый ключ имени DNS
- **NSEC** Next Secure — Используется вместе с спецификацией DNSSEC для генерации отказов
- **NSEC3** Next Secure v3 — Используется вместе с спецификацией DNSSEC для генерации отказов
- **RRSIG** Signature — Множество подписанных аутентифицированных записей о ресурсах

Вспомогательные

- **CNAME** Canonical Name — Дополнительные имена хоста
- **SRV** Services — Местонахождение извесных служб в пределах домена
- **TXT** Text — Комментарии или нестандартная информация

`ping` — посылает пакеты **ICMP ECHO_REQUEST** узлам в сети;
`traceroute` — выводит трассировку маршрута пакетов к сетевому узлу;
`ip` — отображает информацию о маршрутах, устройствах, политиках маршрутизации и туннелях и позволяет управлять ими;
`netstat` — выводит список сетевых соединений, таблицы маршрутов, статистику интерфейсов, маскируемые соединения и сведения о членстве в широковещательных группах;
`ftp` — программа передачи файлов через Интернет;
`wget` — неинтерактивный загрузчик файлов из сети;
`ssh` — клиент OpenSSH SSH (программа для входа в удаленные системы).

### Виртуализация и Контейнеризация

### Виртуализация

Виртуализация — задача поддержки нескольких сред

Эмуляция — задача имитации оборудования для отдельной среды

Системными ресурсы — Процессорное время, память и устройства ввода\вывода.
Виртуальная машина(_VM_) — Изолированная оперционная система
**Гипервизор** — посредник между _VM_ и аппаратным обеспечением, управляющий системными ресурсами
Виртуальные машины получают доступ к системным ресурсам **_исключительно_** через гипервизор

### Полная виртуализация

Гипервизор полностью эмулирует базовое оборудование, изолированные ОС используют виртуальные: уст-ва управления прерываниями, сетевые уст-ва, материнские платы, жесткие диски, BIOS…
**+** Не требует модификации ОС

- Не требует особого оборудования
  **-** Низкая скорость(издержки эмуляции всего оборудования)

### Паравиртуализация

Модифицированная ОС распознает свое виртуальное состояние и активно взаимодействует с гипервизором для организации доступа к аппарутному обеспечению

- средняя производительность

* ОС должны быть сильно модифицированны

### Аппаратная виртуализация

Процессор и контроллер памяти виртуализируется с помощью аппаратного обеспечения, хотя и под управлением гипервизора(для эмуляции аппаратного обеспечения, помимо ЦП)

- Высокая скорость
- Не требует модификации ОС

* требуется процессор поддерживающий виртуализацию

### Динамическая миграция

Динамическая миграция — Виртуальные машины могут перемещаться между гипервизорами, работающими на разных физиеских уст-вах, в реальном времени, без перерывов в обслуживании или потери связи.

### Контейнеризация

Контейнеризация — Виртуализация на уровне ОС при которой используются функции ядра, которые позволяют изолировать процессы от остальной системы

- **Требуется совместимое ядро ОС**(Исключает использование нескольких видов ОС)
- Не требуется виртуализация

У каждого контейнера процесса:

- своя файловую систему
- свое пространство имен процессов
- совместно использует ядро и другие службы хост-системы
- не может обращаться к файлам или ресурсам за пределами своих контейнеров
- Отличия от вирутализации

### Контейнеризация

Задача — упаковать приложение и его вспомогательные средства в стандартный переносимы файл

Контейнер — представляет собой изолированную группу процессов, которые ограничены частной корневой файловой системой и пространством имен процессов

- Используемые функции ядра:
  - _Пространства имен_ — изолируют контейнерные процессы с точки зрения нескольких функций операционной системы, включая монтирование файловой системы, управление процессами и сетевое взаимодействие
  - _Контрольные группы_ — ограничивают использование системных ресурсов и определяют приоритетность одних процессов над другими.
    Не позволяют контейнерам, выходящим из-под контроля, использовать всю память и процессорное время
  - _Функциональные возможности_ — позволяют процессам выполнять определенные чувствительные операции с ядром или системные вызовы.
    (изменять права собственности на файл)
  - _Режим защищенных вычислений_ — ограничивает доступ к системным вызовам.

**Образ** — шаблон для контейнера

- использует точку монтирования объединенной файловой системы для производительности и переносимости, состоит из 2 слоев
  - слой образа — только для чтения
  - слой контейнера — если изменяет данные образа, копирует их в этот слой и изменяет(_copy-on-write_)
- структура каталога соответствует структуре корня Linux

**Сеть**

Хост — маршрутизатор-прокси (между миром и контейнерами)

Для подключения к контейнеру используют Unix-сокеты или TCP

Сетевой режим хоста — контейнер имеет не ограниченный доступ к сетевому стеку х

### Docker

docker — команда, которая выполняет задачи по управлению системой Docker

dockerd — демон, который выполняет операции с контейнерами и образами

- создает виртуальную сеть
- поддерживает каталог, в котором хранятся контейнеры и образы(`/var/lib/docker`)
- создает контейнеры, настраивая объединенную файловую систему и исполняющие процессы
- создает уровень файловой системы с возможностью записи, отделенный от исходного образа
  Если уровень fs используется в нескольких образах, нужна только одна копия

![Untitled](Linux%20f9b903ea36464de99f152d6ee4d1b7e6/Untitled%204.png)

- Удаленное подключение к dockerd
  `export DOCKER_HOST=tcp://10.0.0.10:2376`
  порт 2375 — обычный HTTP
  порт 2376 — TLS

`sudo systemctl start docker` — Запустить докер
`sudo systemctl enable docker` — Запускать докер при запуске системы

`docker info` — Отображает сводную информацию о демоне

`docker ps` — Отображает запущенные контейнеры

`docker version` — Информация о версии сервера и клиента

`docker rm` — Удаляет Контейнер

`docker rmi` — Удаляет Образ

`docker images` — Отображает локальные образы

`docker inspect` — Отображает конфигурацию контейнера

`docker logs` — Отображает стандартный вывод из контейнера

`docker exec` — Выполняет команду(запускает процесс) в существуюющем контейнере

- `docker run` [options] image [command] [args] — Запускает новый контейнер
  `--attach-a` — Attach to STDIN, STDOUT or STDERR
  `--interactive` `-i` — Оставляет STDIN открытым, даже если он не подключен
  `--tty` `-t` — Allocate a pseudo-TT
  `-it` — интерактивная обочка
  `--detach` `-d` — фоновый режим
  `--publish` `-p` h:c — прокладывает туннель
  `--volume` `-v` — Привязать монтируемый том
  `--volumes-from` — Монтировать тома из указанного контейнера
  `--workdir` `-w` — запускает команду, выполняемую внутри указанного каталога,
  `--hostname` `-h` — задать hostname
  `--name` — задать контейнеру имя

`docker start/stop` — Запускает/Останавливает существующий контейнер

`docker pull/push` — Загружает образы в/из удаленного реестра

`docker top` — Отображает состояние контейнерного процесса

Образ — шаблон для контейнера, включающий файлы, библиотеки, приложения от которых зависит запускаемый процесс
одному образу можно назначить несколько тегов

### SSH

- `ssh` *[опции] [имя*пользователя*@*]хост [команда]\_ — клиент
  Если не указать имя пользователя, будет использовано локальное имя пользователя(имя на текущем компьютере) на удаленном хосте

`sshd` — демон сервера
`ssh-keygen` — команда для генерации пар открытых-закрытых ключей;
`ssh-add` и `ssh-agent` — утилиты для управления ключами аутентификации;
`ssh-keyscan` — для извлечения открытых ключей с серверов;
`sftp- server` — серверный процесс для передачи файлов через протокол SFТP;
`sftp` и `scp` — утилиты для передачи файлов.

- Аутентификация с помощью открытого ключа
  1. Создать пару открытый-закрытый ключ
     `ssh-keygen -t ed25519 -C "vahrameev.work@gmail.com"`
  2. Передать свой **открытый** ключ на удаленный сервер, в файл `~/.ssh/authorized_keys`
     - Если вы администратор
       1. Убедитесь, что у пользователя есть активная учетная запись с корректной системной оболочкой.
       2. Получите копию открытого ключа пользователя от самого пользователя .
       3. Создайте пользовател ьский каталог `~***user***/.ssh/` с разрешениями 0700.
       4. Добавьте открытый ключ в файл `~***user***/.ssh/authorized_keys`
          и установите разрешения для этого файла 0600.
       - code
         ```bash
         grep ***user*** /etc/passwd
         mkdir -р ~***user***/.ssh && chmod 0700 ~***user***/.ssh
         cat /tmp/***user***.pub >> -***user***/.ssh/authorized_keys
         chmod 0 600 ~***user***/.ssh/authorized_keys
         ```
  3. Войти на удаленный сервер при помощи **закрытого** ключа

### Мониторинг

`df` _-h_ — объем свободного пространства на дисках

`free` — объем свободного пространства в памяти

- создать сервер OpenVPN
  `wget https://git.io/vpn -O openvpn-install.sh && bash`
