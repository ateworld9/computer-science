# Бинарный поиск

**Общий алгоритм:**

1. Определение значения элемента в середине структуры данных. Полученное значение сравнивается с ключом.
2. Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.
3. Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с ключом.
4. Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.

**Применим**:

- найти элемент в отсортированном массиве
- найти первый удовлетворяющий условию
- найти последний удовлетворяющий условию
- найти одинаковые элементы (или их количество)

**Реализации**:

- индекс элемента
  Если целевых элементов несколько, возвращает случайный из них
  ```jsx
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
  const binarySearch = (nums, target) => {
  	let left = 0;
  	let right = nums.length - 1;
  	while (left <= right) {
  		const midIndex = (left + right) >> 1;
  		// const midIndex = (left + right) >>> 1;
  		// const midIndex = (left + right) / 2; // bug with int overflow
  		const mid = nums[midIndex];
  		if (mid === target) {
  			return midIndex;
  		} else if (mid > target) {
  			right = midIndex - 1;
  		} else {
  			left = midIndex + 1;
  		}
  	}
  	return -1;
  };
  ```
- первый удовлетворяющий условию
  ```jsx
  function leftBinarySearch(l, r, check, checkparams) {
  	while (l < r) {
  		const m = Math.floor((l + r) / 2);
  		if (check(m, checkparams)) r = m;
  		else l = m + 1;
  	}
  	return l;
  }
  ```
- последний удовлетворяющий условию

  ```jsx
  function rightBinarySearch(l, r, check, checkparams) {
  	while (l < r) {
  		const m = Math.ceil((l + r) / 2);
  		if (check(m, checkparams)) l = m;
  		else r = m - 1;
  	}
  	return l;
  }
  ```

**Сложность:** $O(log\,n)$

**Распространенные ошибки:**

- не работает с массивом из 0/1/2 элементов
- не находит первый или последний элемент
- некорректно работает, если элемента в массиве нет
- некорректно работает, если в массиве есть повторяющиеся элементы
- обращение к элементами за пределами массива
- козырная, которая была в JDK, переполнение целого при вычислении среднего индекса
